'''
【动态规划】 题目: (矩阵最大正方形) 在一个由 0 和 1 组成的二维矩阵内，找到只包含 1 的最大正方形，并返回其面积
'''
'''
输入: 
1 0 1 0 0
1 0 1 1 1
1 1 1 1 1
1 0 0 1 0
输出: 4
'''
'''
思路: 动态规划: 
如果我们能够判断一个点是正方形右下角的点的话，那么肯定可以确定它的左边、上边和左上三个点，分别都是某个正方形的右下角的点。
关于边长：以当前点为右下角的正方形的边长，最多比左边、上边和左上的正方形的边长多1，最好的情况是这三个正方形的边长大小相同（不一定是1），
那么加上当前点就可以凑成一个更大的正方形。 如果这三个正方形边长不一样，那么合起来就会缺了某个角，因此就要取这三个边长中的最小值加1
'''
'''
用 mem 数组来记录在当前位置的元素上可以取到的最大正方形的边长的值, 以当前位置为正方形的右下角
用 res 值来维护整个矩阵中可以取到的最大正方形的边长的值
'''

def maximalSquare(matrix):
    '''
    :param matrix: m 行 n 列
    :return:
    '''
    # m 行 n 列
    m = len(matrix)
    if m == 0:
        return 0
    n = len(matrix[0])
    if n == 0:
        return 0

    # res 用于保存矩阵中最大正方形的边长
    res = 0

    # mem 数组记录每一个位置能够取到的正方形的最大边长
    mem = [[0 for _ in range(n)] for _ in range(m)]

    # 矩阵最左侧一列如果存在为 1 的元素，那么该位置的最大正方形边长就是 1
    # 更新整个矩阵的最大正方形边长 res
    for i in range(0, m):
        if matrix[i][0] == 1:
            mem[i][0] = 1
            res = 1

    # 矩阵最上面一行如果存在为 1 的元素，那么该位置的最大正方形边长就是 1
    # 更新整个矩阵的最大正方形边长 res
    for j in range(1, n):
        if matrix[0][j] == 1:
            mem[0][j] = 1
            res = 1

    # 动态规划
    for i in range(1, m):
        for j in range(1, n):
            if matrix[i][j] == 1:
                mem[i][j] = min(mem[i-1][j-1], mem[i-1][j], mem[i][j-1]) + 1
            res = max(res, mem[i][j])

    return res*res

# 验证
matrix = [[1,0,1,1,1],[1,0,1,1,1],[1,1,1,1,1],[1,0,0,1,0]]
print(maximalSquare(matrix))